71d70
<         for (int i = 0; i < a.length; i++) aux[i] = a[i];
113,117d111
<         // copy to aux[]
<         for (int k = lo; k <= hi; k++) {
<             aux[k] = index[k]; 
<         }
< 
134c128
<     public static int[] indexSort(Comparable[] a) {
---
>     public static void indexSort(Comparable[] a) {
137,139d130
<         for (int i = 0; i < N; i++)
<             index[i] = i;
< 
141,142c132,144
<         sort(a, index, aux, 0, N-1);
<         return index;
---
>         for (int i = 0; i < N; i++) index[i] = aux[i] = i;
> 
>         sort(a, aux, index, 0, N-1);	// below
> 
> 		// cyclic permutation
> 		for (int i = 0; i < N; i++ ) {
> 			int	k, j = index[i];
> 			if (j != i) {
> 				Comparable	v = a[j = i];
> 				for(;(k = index[j]) != i; j = k) a[index[j] = j] = a[k];
> 				a[index[j] = j] = v;
> 			}
> 		}
149,151c151,153
<         sort(a, index, aux, lo, mid);
<         sort(a, index, aux, mid + 1, hi);
<         merge(a, index, aux, lo, mid, hi);
---
>         sort(a, aux, index, lo, mid);		// recursive
>         sort(a, aux, index, mid + 1, hi);
>         merge(a, aux, index, lo, mid, hi);	// Index mergesort above
168c170
<         MergeWidx.sort(a);
---
>         MergeWidx.indexSort(a);
