35c35
<  */
---
> */
72d71
<         for (int i = 0; i < a.length; i++) aux[i] = a[i];
114,118d112
<         // copy to aux[]
<         for (int k = lo; k <= hi; k++) {
<             aux[k] = index[k]; 
<         }
< 
135c129
<     public static int[] indexSort(Comparable[] a) {
---
>     public static void indexSort(Comparable[] a) {
138,140d131
<         for (int i = 0; i < N; i++)
<             index[i] = i;
< 
142,143c133,145
<         sort(a, index, aux, 0, N-1);
<         return index;
---
>         for (int i = 0; i < N; i++) index[i] = aux[i] = i;
> 
>         sort(a, aux, index, 0, N-1);	// below
> 
> 		// cyclic permutation
> 		for (int i = 0; i < N; i++ ) {
> 			int	k, j = index[i];
> 			if (j != i) {
> 				Comparable	v = a[j = i];
> 				for(;(k = index[j]) != i; j = k) a[index[j] = j] = a[k];
> 				a[index[j] = j] = v;
> 			}
> 		}
150,152c152,154
<         sort(a, index, aux, lo, mid);
<         sort(a, index, aux, mid + 1, hi);
<         merge(a, index, aux, lo, mid, hi);
---
>         sort(a, aux, index, lo, mid);		// recursive
>         sort(a, aux, index, mid + 1, hi);
>         merge(a, aux, index, lo, mid, hi);	// Index mergesort above
169c171
<         MergeWidx.sort(a);
---
>         MergeWidx.indexSort(a);
