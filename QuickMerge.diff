36,37c36,37
<     private static final int CUTOFF = 40;  // cutoff to middle pivot, must be >= 1
< 	private static final double Merge = Math.log(2);
---
>     private static final int CUTOFF = 5;  // cutoff to middle pivot, must be >= 1
> 	private static final double Log2 = Math.log(2);
47c47
<         sort(a, 0, a.length - 1);
---
>         sort(a, 0, a.length - 1, 0);
51c51
<     private static void sort(Comparable[] a, int lo, int hi) { 
---
>     private static void sort(Comparable[] a, int lo, int hi, int depth) { 
54c54,60
< 		if (N <= CUTOFF) j = lo + (hi - lo) / 2;		// middle element
---
> 		if (++depth > CUTOFF) {
> 			Comparable[] aux = new Comparable[N];
> 			for (i = 0; i < N; i++) aux[i] = a[lo + i]; 
> 			MergeInsert.sort(aux);
> 			for (i = 0; i < N; i++) a[lo + i] = aux[i]; 
> 			return;
> 		}
56c62
< 			int L = ((int)(Math.log(N) / Merge) - 1) | 1;	// odd(log2(N))
---
> 			int L = ((int)(Math.log(N) / Log2) - 1) | 1;	// odd(log2(N))
86,87c92,93
<         sort(a, lo, hole - 1);
<         sort(a, (k < 0 ? hole : k) + 1, hi);
---
>         sort(a, lo, hole - 1, depth);
>         sort(a, (k < 0 ? hole : k) + 1, hi, depth);
